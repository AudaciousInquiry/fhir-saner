#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = __importDefault(require("commander"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const import_1 = require("./import");
const export_1 = require("./export");
const ig_1 = require("./ig");
const utils_1 = require("./utils");
const fhirdefs_1 = require("./fhirdefs");
const fhirdefs_2 = require("./fhirdefs");
const utils_2 = require("./utils");
app();
function app() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        let input;
        commander_1.default
            .name('sushi')
            .usage('<path-to-fsh-defs> [options]')
            .option('-o, --out <out>', 'the path to the output folder', path_1.default.join('.', 'build'))
            .option('-d, --debug', 'output extra debugging information')
            .option('-s, --snapshot', 'generate snapshot in Structure Definition output', false)
            .version(getVersion(), '-v, --version', 'print SUSHI version')
            .arguments('<path-to-fsh-defs>')
            .action(function (pathToFshDefs) {
            input = pathToFshDefs;
        })
            .parse(process.argv);
        if (commander_1.default.debug)
            utils_1.logger.level = 'debug';
        // Check that input folder is specified
        if (!input) {
            utils_1.logger.error('Missing path to FSH definition folder.');
            commander_1.default.help();
        }
        let files;
        try {
            files = getFilesRecursive(input);
        }
        catch (_c) {
            utils_1.logger.error('Invalid path to FSH definition folder.');
            commander_1.default.help();
        }
        // Check that package.json exists
        const packagePath = path_1.default.join(input, 'package.json');
        if (!fs_extra_1.default.existsSync(packagePath)) {
            utils_1.logger.error('No package.json in FSH definition folder.');
            return;
        }
        // Parse package.json
        let config;
        try {
            config = fs_extra_1.default.readJSONSync(packagePath);
        }
        catch (e) {
            utils_1.logger.error(`The package.json file is not valid JSON: ${packagePath}`);
            return;
        }
        // Load external dependencies
        const defs = new fhirdefs_2.FHIRDefinitions();
        const dependencyDefs = [];
        for (const dep of Object.keys((_b = (_a = config) === null || _a === void 0 ? void 0 : _a.dependencies, (_b !== null && _b !== void 0 ? _b : {})))) {
            dependencyDefs.push(fhirdefs_1.loadDependency(dep, config.dependencies[dep], defs)
                .then(def => {
                utils_1.logger.info(`Loaded package ${dep}#${config.dependencies[dep]}`);
                return def;
            })
                .catch(e => {
                utils_1.logger.error(`Failed to load ${dep}#${config.dependencies[dep]}`);
                utils_1.logger.error(e.message);
            }));
        }
        // Load custom resources specified in ig-data folder
        fhirdefs_1.loadCustomResources(input, defs);
        const rawFSHes = files
            .filter(file => file.endsWith('.fsh'))
            .map(file => {
            const filePath = path_1.default.resolve(file);
            const fileContent = fs_extra_1.default.readFileSync(filePath, 'utf8');
            return new import_1.RawFSH(fileContent, filePath);
        });
        utils_1.logger.info('Importing FSH text...');
        const docs = import_1.importText(rawFSHes);
        const tank = new import_1.FSHTank(docs, config);
        yield Promise.all(dependencyDefs);
        utils_1.logger.info('Converting FSH to FHIR resources...');
        const outPackage = export_1.exportFHIR(tank, defs);
        fs_extra_1.default.ensureDirSync(commander_1.default.out);
        fs_extra_1.default.writeFileSync(path_1.default.join(commander_1.default.out, 'package.json'), JSON.stringify(outPackage.config, null, 2), 'utf8');
        utils_1.logger.info('Exporting FHIR resources as JSON...');
        let count = 0;
        const writeResources = (folder, resources) => {
            const exportDir = path_1.default.join(commander_1.default.out, 'input', folder);
            resources.forEach(resource => {
                fs_extra_1.default.outputJSONSync(path_1.default.join(exportDir, resource.getFileName()), resource.toJSON(commander_1.default.snapshot), {
                    spaces: 2
                });
                count++;
            });
        };
        writeResources('profiles', outPackage.profiles);
        writeResources('extensions', outPackage.extensions);
        writeResources('vocabulary', [...outPackage.valueSets, ...outPackage.codeSystems]);
        // Sort instances into appropriate directories
        const instances = cloneDeep_1.default(outPackage.instances); // Filter functions below mutate the argument, so clone what is in the package
        utils_2.filterInlineInstances(instances);
        writeResources('examples', utils_2.filterExampleInstances(instances));
        writeResources('capabilities', utils_2.filterCapabilitiesInstances(instances));
        writeResources('vocabulary', utils_2.filterVocabularyInstances(instances));
        writeResources('models', utils_2.filterModelInstances(instances));
        writeResources('operations', utils_2.filterOperationInstances(instances));
        writeResources('extensions', utils_2.filterExtensionInstances(instances));
        writeResources('profiles', utils_2.filterProfileInstances(instances));
        writeResources('resources', instances); // Any instance left cannot be categorized any further so should just be in generic resources
        utils_1.logger.info(`Exported ${count} FHIR resources as JSON.`);
        // If ig-data exists, generate an IG, otherwise, generate resources only
        const igDataPath = path_1.default.resolve(input, 'ig-data');
        if (fs_extra_1.default.existsSync(igDataPath)) {
            utils_1.logger.info('Assembling Implementation Guide sources...');
            const igExporter = new ig_1.IGExporter(outPackage, defs, igDataPath);
            igExporter.export(commander_1.default.out);
            utils_1.logger.info('Assembled Implementation Guide sources; ready for IG Publisher.');
        }
        utils_1.logger.info(`
  Profiles:    ${outPackage.profiles.length}
  Extensions:  ${outPackage.extensions.length}
  Instances:   ${outPackage.instances.length}
  ValueSets:   ${outPackage.valueSets.length}
  CodeSystems: ${outPackage.codeSystems.length}
  Errors:      ${utils_1.stats.numError}
  Warnings:    ${utils_1.stats.numWarn}`);
        const exitCode = utils_1.stats.numError > 0 ? 1 : 0;
        process.exit(exitCode);
    });
}
function getVersion() {
    const packageJSONPath = path_1.default.join(__dirname, '..', 'package.json');
    if (fs_extra_1.default.existsSync(packageJSONPath)) {
        const packageJSON = fs_extra_1.default.readJSONSync(packageJSONPath);
        return `v${packageJSON.version}`;
    }
    return 'unknown';
}
function getFilesRecursive(dir) {
    if (fs_extra_1.default.statSync(dir).isDirectory()) {
        const ancestors = fs_extra_1.default.readdirSync(dir, 'utf8').map(f => getFilesRecursive(path_1.default.join(dir, f)));
        return [].concat(...ancestors);
    }
    else {
        return [dir];
    }
}
//# sourceMappingURL=app.js.map