"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rules_1 = require("../fshtypes/rules");
const fshtypes_1 = require("../fshtypes");
const Fishable_1 = require("../utils/Fishable");
const cloneDeep = require("lodash/cloneDeep");
const utils_1 = require("../utils");
const primitiveTypes_1 = require("./primitiveTypes");
function splitOnPathPeriods(path) {
    return path.split(/\.(?![^\[]*\])/g); // match a period that isn't within square brackets
}
exports.splitOnPathPeriods = splitOnPathPeriods;
/**
 * This function sets an instance property of an SD or ED if possible
 * @param {StructureDefinition | ElementDefinition} - The instance to fix a value on
 * @param {string} path - The path to fix a value at
 * @param {any} value - The value to fix
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 */
function setPropertyOnDefinitionInstance(instance, path, value, fisher) {
    const instanceSD = instance.getOwnStructureDefinition(fisher);
    const { fixedValue, pathParts } = instanceSD.validateValueAtPath(path, value, fisher);
    setPropertyOnInstance(instance, pathParts, fixedValue);
}
exports.setPropertyOnDefinitionInstance = setPropertyOnDefinitionInstance;
function setPropertyOnInstance(instance, pathParts, fixedValue) {
    var _a;
    if (fixedValue != null) {
        // If we can fix the value on the StructureDefinition StructureDefinition, then we can set the
        // instance property here
        let current = instance;
        for (const [i, pathPart] of pathParts.entries()) {
            // When a primitive has child elements, a _ is appended to the name of the primitive
            // According to https://www.hl7.org/fhir/json.html#primitive
            const key = pathPart.primitive && i < pathParts.length - 1 ? `_${pathPart.base}` : pathPart.base;
            // If this part of the path indexes into an array, the index will be the last bracket
            let index = getArrayIndex(pathPart);
            let sliceName;
            if (index != null) {
                // If the array doesn't exist, create it
                if (current[key] == null)
                    current[key] = [];
                sliceName = getSliceName(pathPart);
                if (sliceName) {
                    if (typeof fixedValue !== 'object') {
                        // When a fixedValue is a primitive but also a slice, we convert to an object so that
                        // the sliceName field can be tracked on the object. The _primitive field marks the object
                        // to later be converted back to a primitive by replaceField in cleanInstance
                        fixedValue = { fixedValue, _primitive: true };
                    }
                    const sliceIndices = [];
                    // Find the indices where slices are placed
                    (_a = current[pathPart.base]) === null || _a === void 0 ? void 0 : _a.forEach((el, i) => {
                        var _a;
                        if (((_a = el) === null || _a === void 0 ? void 0 : _a._sliceName) === sliceName) {
                            sliceIndices.push(i);
                        }
                    });
                    // Convert the index in terms of the slice to the corresponding index in the overall array
                    if (index >= sliceIndices.length) {
                        index = index - sliceIndices.length + current[key].length;
                    }
                    else {
                        index = sliceIndices[index];
                    }
                }
                // If the index doesn't exist in the array, add it and lesser indices
                // Empty elements should be null, not undefined, according to https://www.hl7.org/fhir/json.html#primitive
                for (let j = 0; j <= index; j++) {
                    if (j < current[key].length && j === index && current[key][index] == null) {
                        current[key][index] = {};
                    }
                    else if (j >= current[key].length) {
                        if (sliceName) {
                            // _sliceName is used to later differentiate which slice an element represents
                            current[key].push({ _sliceName: sliceName });
                        }
                        else if (j === index) {
                            current[key].push({});
                        }
                        else {
                            current[key].push(null);
                        }
                    }
                }
                // If it isn't the last element, move on, if it is, set the value
                if (i < pathParts.length - 1) {
                    current = current[key][index];
                    if (sliceName) {
                        current._sliceName = sliceName;
                    }
                }
                else {
                    if (typeof fixedValue === 'object') {
                        Object.assign(current[key][index], fixedValue);
                    }
                    else {
                        current[key][index] = fixedValue;
                    }
                }
            }
            else {
                // If it isn't the last element, move on, if it is, set the value
                if (i < pathParts.length - 1) {
                    if (current[key] == null)
                        current[key] = {};
                    current = current[key];
                }
                else {
                    current[key] = fixedValue;
                }
            }
        }
    }
}
exports.setPropertyOnInstance = setPropertyOnInstance;
/**
 * Tests to see if the last bracket in a PathPart is a non-negative int, and if so returns it
 * @param {PathPart} pathPart - The part of the path to test
 * @returns {number} The index if it exists and is non-negative, otherwise undefined
 *
 */
function getArrayIndex(pathPart) {
    var _a;
    const lastBracket = (_a = pathPart.brackets) === null || _a === void 0 ? void 0 : _a.slice(-1)[0];
    let arrayIndex;
    if (/^[-+]?\d+$/.test(lastBracket)) {
        arrayIndex = parseInt(lastBracket);
    }
    return arrayIndex >= 0 ? arrayIndex : null;
}
exports.getArrayIndex = getArrayIndex;
/**
 * Replaces references to instances by the correct path to that instance.
 * Replaces references to local code systems by the url for that code system.
 * @param {FixedValueRule} rule - The rule to replace references on
 * @param {FSHTank} tank - The tank holding the instances and code systems
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * @returns {FixedValueRule} a clone of the rule if replacing is done, otherwise the original rule
 */
function replaceReferences(rule, tank, fisher) {
    var _a, _b, _c, _d;
    let clone;
    if (rule.fixedValue instanceof fshtypes_1.FshReference) {
        const instance = tank.fish(rule.fixedValue.reference, Fishable_1.Type.Instance);
        const instanceMeta = fisher.fishForMetadata((_a = instance) === null || _a === void 0 ? void 0 : _a.instanceOf, Fishable_1.Type.Resource, Fishable_1.Type.Type, Fishable_1.Type.Profile, Fishable_1.Type.Extension);
        // If we can't find a matching instance, just leave the reference as is
        if (instance && instanceMeta) {
            // If the instance has a rule setting id, that overrides instance.id
            const idRule = instance.rules.find(r => r.path === 'id');
            const id = (_c = (_b = idRule) === null || _b === void 0 ? void 0 : _b.fixedValue, (_c !== null && _c !== void 0 ? _c : instance.id));
            clone = cloneDeep(rule);
            const fv = clone.fixedValue;
            fv.reference = `${instanceMeta.sdType}/${id}`;
        }
    }
    else if (rule.fixedValue instanceof fshtypes_1.FshCode) {
        const codeSystem = tank.fish(rule.fixedValue.system, Fishable_1.Type.CodeSystem);
        const codeSystemMeta = fisher.fishForMetadata((_d = codeSystem) === null || _d === void 0 ? void 0 : _d.name, Fishable_1.Type.CodeSystem);
        if (codeSystem && codeSystemMeta) {
            clone = cloneDeep(rule);
            const fv = clone.fixedValue;
            fv.system = codeSystemMeta.url;
        }
    }
    return (clone !== null && clone !== void 0 ? clone : rule);
}
exports.replaceReferences = replaceReferences;
/**
 * Returns the sliceName for a set of pathParts
 * @param {PathPart} pathPart - The part of the path to get a sliceName for
 * @returns {string} The slicenName for the path part
 */
function getSliceName(pathPart) {
    const arrayIndex = getArrayIndex(pathPart);
    const nonNumericBrackets = arrayIndex == null ? pathPart.brackets : pathPart.brackets.slice(0, -1);
    return nonNumericBrackets.join('/');
}
exports.getSliceName = getSliceName;
/**
 * Replaces fields in an object that match a certain condition
 * @param { {[key: string]: any} } object - The object to replace fields on
 * @param {(object: { [key: string]: any }, prop: string) => boolean} matchFn - The function to match with
 * @param {(object: { [key: string]: any }, prop: string) => void} replaceFn - The function to replace with
 */
function replaceField(object, matchFn, replaceFn) {
    for (const prop in object) {
        if (matchFn(object, prop)) {
            replaceFn(object, prop);
        }
        else if (typeof object[prop] === 'object') {
            replaceField(object[prop], matchFn, replaceFn);
        }
    }
}
exports.replaceField = replaceField;
/**
 * Adds Mixin rules onto a Profile, Extension, or Instance
 * @param {Profile | Extension | Instance} fshDefinition - The definition to apply mixin rules on
 * @param {FSHTank} tank - The FSHTank containing the fshDefinition
 */
function applyMixinRules(fshDefinition, tank) {
    // Rules are added to beginning of rules array, so add the last mixin rules first
    const mixedInRules = [];
    fshDefinition.mixins.forEach(mixinName => {
        const ruleSet = tank.fish(mixinName, Fishable_1.Type.RuleSet);
        if (ruleSet) {
            ruleSet.rules.forEach(r => {
                // Record source information of Profile/Extension/Instance on which Mixin is applied
                r.sourceInfo.appliedFile = fshDefinition.sourceInfo.file;
                r.sourceInfo.appliedLocation = fshDefinition.sourceInfo.location;
            });
            const rules = ruleSet.rules.filter(r => {
                if (fshDefinition instanceof fshtypes_1.Instance && !(r instanceof rules_1.FixedValueRule)) {
                    utils_1.logger.error('Rules applied by mixins to an instance must fix a value. Other rules are ignored.', r.sourceInfo);
                    return false;
                }
                return true;
            });
            mixedInRules.push(...rules);
        }
        else {
            utils_1.logger.error(`Unable to find definition for RuleSet ${mixinName}.`, fshDefinition.sourceInfo);
        }
    });
    fshDefinition.rules = [...mixedInRules, ...fshDefinition.rules];
}
exports.applyMixinRules = applyMixinRules;
const nameRegex = /^[A-Z]([A-Za-z0-9_]){0,254}$/;
class HasName {
    /**
     * Set the name and check if it matches the regular expression specified
     * in the invariant for "name" properties. A name must be between 1 and 255 characters long,
     * begin with an uppercase letter, and contain only uppercase letter, lowercase letter,
     * numeral, and '_' characters.
     * If the string does not match, log an error.
     *
     * @see {@link http://hl7.org/fhir/R4/structuredefinition-definitions.html#StructureDefinition.name}
     * @see {@link http://hl7.org/fhir/R4/valueset-definitions.html#ValueSet.name}
     * @see {@link http://hl7.org/fhir/R4/codesystem-definitions.html#CodeSystem.name}
     * @param {string} name - The name to check against the name invariant
     * @param {SourceInfo} sourceInfo - The FSH file and location that specified the name
     */
    setName(name, sourceInfo) {
        this.name = name;
        if (!nameRegex.test(name)) {
            utils_1.logger.error(`The string "${name}" does not represent a valid FHIR name. Valid names start with an upper-case ASCII letter ('A'..'Z') followed by any combination of of upper- or lower-case ASCII letters ('A'..'Z', and 'a'..'z'), numerals ('0'..'9') and '_', with a length limit of 255 characters.`, sourceInfo);
        }
    }
}
exports.HasName = HasName;
class HasId {
    /**
     * Set the id and check if it matches the regular expression specified
     * in the definition of the "id" type.
     * If the FHIRId does not match, log an error.
     *
     * @param id - The new id to set
     * @param sourceInfo - The FSH file and location that specified the id
     */
    setId(id, sourceInfo) {
        this.id = id;
        this.validateId(sourceInfo);
    }
    /**
     * Check if the current id matches the regular expression specified
     * in the definition of the "id" type.
     * If the FHIRId does not match, log an error.
     *
     * @param sourceInfo - The FSH file and location that specified the id
     */
    validateId(sourceInfo) {
        if (!primitiveTypes_1.idRegex.test(this.id)) {
            utils_1.logger.error(`The string "${this.id}" does not represent a valid FHIR id. FHIR ids may contain any combination of upper- or lower-case ASCII letters ('A'..'Z', and 'a'..'z'), numerals ('0'..'9'), '-' and '.', with a length limit of 64 characters.`, sourceInfo);
        }
    }
}
exports.HasId = HasId;
//# sourceMappingURL=common.js.map