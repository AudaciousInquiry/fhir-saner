"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ini_1 = __importDefault(require("ini"));
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const words_1 = __importDefault(require("lodash/words"));
const title_case_1 = require("title-case");
const fs_extra_2 = require("fs-extra");
const utils_1 = require("../utils");
/**
 * The IG Exporter exports the FSH artifacts into a file structure supported by the IG Publisher.
 * This allows a FSH Tank to be built as a FHIR IG.  Currently, template-based IG publishing is
 * still new, so this functionality is subject to change.
 *
 * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/index.html}
 */
class IGExporter {
    constructor(pkg, fhirDefs, igDataPath) {
        this.pkg = pkg;
        this.fhirDefs = fhirDefs;
        this.igDataPath = igDataPath;
    }
    /**
     * Export the IG structure to the location specified by the outPath argument
     * @param outPath {string} - the path to export the IG file structure to
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#directory-structure}
     */
    export(outPath) {
        fs_extra_2.ensureDirSync(outPath);
        this.initIG();
        this.addResources();
        this.addPredefinedResources(outPath);
        this.addStaticFiles(outPath);
        this.addIndex(outPath);
        this.addOtherPageContent(outPath);
        this.addImages(outPath);
        this.addIncludeContents(outPath);
        this.addIgIni(outPath);
        this.addPackageList(outPath);
        this.addIgnoreWarningsFile(outPath);
        this.addImplementationGuide(outPath);
    }
    /**
     * Initializes the ImplementationGuide JSON w/ data from the package.json
     *
     * @see {@link https://confluence.hl7.org/pages/viewpage.action?pageId=35718629#NPMPackageSpecification-PackageManifestpropertiesforIGs}
     */
    initIG() {
        var _a, _b, _c;
        const config = this.pkg.config;
        this.ig = {
            resourceType: 'ImplementationGuide',
            id: config.name,
            url: `${config.canonical}/ImplementationGuide/${config.name}`,
            version: config.version,
            // name must be alphanumeric (allowing underscore as well)
            name: (_a = config.title, (_a !== null && _a !== void 0 ? _a : config.name)).replace(/[^A-Za-z0-9_]/g, ''),
            title: (_b = config.title, (_b !== null && _b !== void 0 ? _b : config.name)),
            status: 'active',
            publisher: config.author,
            contact: (_c = config.maintainers) === null || _c === void 0 ? void 0 : _c.map(m => {
                var _a;
                const contact = {};
                if (m.name) {
                    contact.name = m.name;
                }
                if (m.url) {
                    contact.telecom = [
                        {
                            system: 'url',
                            value: m.url
                        }
                    ];
                }
                if (m.email) {
                    contact.telecom = (_a = contact.telecom, (_a !== null && _a !== void 0 ? _a : []));
                    contact.telecom.push({
                        system: 'email',
                        value: m.email
                    });
                }
                return contact;
            }),
            description: config.description,
            packageId: config.name,
            license: config.license,
            fhirVersion: ['4.0.1'],
            dependsOn: [],
            definition: {
                resource: [],
                page: {
                    nameUrl: 'toc.html',
                    title: 'Table of Contents',
                    generation: 'html',
                    page: [] // index.[md|html] is required and added later
                },
                // Parameters apparently required by IG Publisher (as of Jan 29, 2020)
                parameter: [
                    {
                        code: 'copyrightyear',
                        value: '' // Gets set when ig.ini is processed
                    },
                    {
                        code: 'releaselabel',
                        value: '' // Gets set when ig.ini is processed
                    },
                    {
                        code: 'show-inherited-invariants',
                        value: 'false' // TODO: Make this configurable
                    }
                ]
            }
        };
        // Add the path-history, if applicable (only applies to HL7 IGs)
        if (/^https?:\/\/hl7.org\//.test(this.pkg.config.canonical)) {
            this.ig.definition.parameter.push({
                code: 'path-history',
                value: `${this.pkg.config.canonical}/history.html`
            });
        }
        // Add the dependencies
        if (this.pkg.config.dependencies) {
            const igs = this.fhirDefs.allImplementationGuides();
            for (const depId of Object.keys(this.pkg.config.dependencies)) {
                if (depId === 'hl7.fhir.r4.core') {
                    continue;
                }
                const depVersion = this.pkg.config.dependencies[depId];
                // find the matching IG by id (for "current"/"dev" version) or id and version (for specific version)
                const depIG = igs.find(ig => ig.packageId === depId &&
                    (ig.version === depVersion || 'current' === depVersion || 'dev' === depVersion));
                if (depIG && depIG.url) {
                    this.ig.dependsOn.push({
                        uri: `${depIG.url}`,
                        packageId: depId,
                        version: depVersion
                    });
                }
                else {
                    utils_1.logger.error(`Failed to add ${depId}:${depVersion} to ImplementationGuide instance.  Could not determine its canonical URL from the FHIR cache.`);
                }
            }
            if (this.ig.dependsOn.length === 0) {
                delete this.ig.dependsOn;
            }
        }
    }
    /**
     * Add the static files that (currently) do not change from IG to IG.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addStaticFiles(igPath) {
        fs_extra_2.copySync(path_1.default.join(__dirname, 'files'), igPath);
        // On Windows, the file permissions are not always preserved. This doesn't
        // cause a problem for the Windows user, but it may cause problems for
        // Mac and Linux users who use an NPM package published by a Windows user.
        // To work around this, we set the necessary permissions on executable
        // scripts after copying them to the IG path.
        try {
            fs_extra_1.default.chmodSync(path_1.default.join(igPath, '_genonce.sh'), 0o755);
            fs_extra_1.default.chmodSync(path_1.default.join(igPath, '_updatePublisher.sh'), 0o755);
        }
        catch (e) {
            // We don't want to fail the whole export for this, but we should log it
            utils_1.logger.warn('Failed to set executable permissions on IG publisher scripts (_genonce.sh, ' +
                '_updatePublisher.sh). You may need to set these permissions manually before they can ' +
                'be executed (e.g., chmod 755 _genonce.sh).');
        }
    }
    /**
     * Add the index.md file.  If the user provided one in ig-data/input/pagecontent,
     * use that -- otherwise create one, setting its content to be the package
     * description.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addIndex(igPath) {
        var _a;
        fs_extra_2.ensureDirSync(path_1.default.join(igPath, 'input', 'pagecontent'));
        // If the user provided an index.md file, use that
        const inputIndexMarkdownPath = path_1.default.join(this.igDataPath, 'input', 'pagecontent', 'index.md');
        const inputIndexXMLPath = path_1.default.join(this.igDataPath, 'input', 'pagecontent', 'index.xml');
        let generation = 'markdown';
        if (fs_extra_1.default.existsSync(inputIndexMarkdownPath)) {
            fs_extra_1.default.copySync(inputIndexMarkdownPath, path_1.default.join(igPath, 'input', 'pagecontent', 'index.md'));
            utils_1.logger.info('Copied ig-data/input/pagecontent/index.md');
        }
        else if (fs_extra_1.default.existsSync(inputIndexXMLPath)) {
            fs_extra_1.default.copySync(inputIndexXMLPath, path_1.default.join(igPath, 'input', 'pagecontent', 'index.xml'));
            generation = 'html';
            utils_1.logger.info('Copied ig-data/input/pagecontent/index.xml');
        }
        else {
            utils_1.logger.info('Generated default index.md.');
            fs_extra_2.outputFileSync(path_1.default.join(igPath, 'input', 'pagecontent', 'index.md'), (_a = this.pkg.config.description, (_a !== null && _a !== void 0 ? _a : '')));
        }
        // Add user-provided or generated index file to IG definition
        this.ig.definition.page.page.push({
            nameUrl: 'index.html',
            title: 'Home',
            generation
        });
    }
    /**
     * Adds additional pages beyond index.md that are defined by the user.
     * Only add formats that are supported by the IG template
     * Intro and notes file contents are injected into relevant pages and should not be treated as their own page
     *
     * @param {string} igPath - the path where the IG is exported to
     */
    addOtherPageContent(igPath) {
        const inputPageContentPath = path_1.default.join(this.igDataPath, 'input', 'pagecontent');
        if (fs_extra_1.default.existsSync(inputPageContentPath)) {
            const organizedPages = this.organizePageContent(fs_extra_1.default.readdirSync(inputPageContentPath));
            let invalidFileTypeIncluded = false;
            organizedPages.forEach(page => {
                // All user defined pages are included in input/pagecontent
                const pagePath = path_1.default.join(this.igDataPath, 'input', 'pagecontent', page.originalName);
                fs_extra_1.default.copySync(pagePath, path_1.default.join(igPath, 'input', 'pagecontent', `${page.name}.${page.fileType}`));
                const isSupportedFileType = page.fileType === 'md' || page.fileType === 'xml';
                const isIntroOrNotesFile = page.name.endsWith('-intro') || page.name.endsWith('-notes');
                if (isSupportedFileType) {
                    // Intro and notes files will be in supported formats but are not separate pages, so they should not be added to IG definition
                    if (!isIntroOrNotesFile) {
                        // Valid page files will be added to the IG definition
                        this.ig.definition.page.page.push({
                            nameUrl: `${page.name}.html`,
                            title: page.title,
                            generation: page.fileType === 'md' ? 'markdown' : 'html'
                        });
                    }
                }
                else {
                    invalidFileTypeIncluded = true;
                }
            });
            if (invalidFileTypeIncluded) {
                const errorString = 'Files not in the supported file types (.md and .xml) were detected. These files will be copied over without any processing.';
                utils_1.logger.warn(errorString, {
                    file: inputPageContentPath
                });
            }
        }
    }
    /**
     * Sorts and renames pages based on numeric prefixes.
     * Numeric prefixes are used for applying a sort order, but should be removed
     * from the page's name and title unless doing so would cause a name collision.
     *
     * @param {string[]} pages - list of file names with extensions
     * @returns {PageMetadata []} - sorted list of file information objects
     */
    organizePageContent(pages) {
        const pageData = pages.map(page => {
            const nameParts = page.match(/^(\d+)_(.*)/);
            let prefix = null;
            let name;
            if (nameParts == null) {
                name = page.slice(0, page.lastIndexOf('.'));
            }
            else {
                prefix = parseInt(nameParts[1]);
                name = nameParts[2].slice(0, nameParts[2].lastIndexOf('.'));
            }
            return {
                originalName: page,
                prefix: prefix,
                name: name,
                title: title_case_1.titleCase(words_1.default(name).join(' ')),
                fileType: page.slice(page.lastIndexOf('.') + 1)
            };
        });
        let mightHaveDuplicates = true;
        while (mightHaveDuplicates) {
            mightHaveDuplicates = false;
            pageData.forEach(page => {
                const sameName = pageData.filter(otherPage => otherPage.name == page.name);
                if (sameName.length > 1) {
                    mightHaveDuplicates = true;
                    sameName.forEach(matchingPage => {
                        matchingPage.name = matchingPage.originalName.slice(0, matchingPage.originalName.lastIndexOf('.'));
                    });
                }
            });
        }
        return pageData.filter(page => page.name !== 'index').sort(this.compareIgFilenames);
    }
    /**
     * Compares two file names, each of which may be prefixed with a number.
     * If neither file has a prefix, compares the file names alphabetically.
     * If one file has a prefix, that file is before the other.
     * If both have a prefix, compares the prefixes numerically.
     * If the prefixes are equal, resolves the tie by comparing the file names alphabetically.
     *
     * @param {PageMetadata} pageA - metadata for first file
     * @param {PageMetadata} pageB - metadata for second file
     * @returns {number} - positive when file b comes first, negative when file a comes first, zero when the file names are equal.
     */
    compareIgFilenames(pageA, pageB) {
        if (pageA.prefix == null && pageB.prefix == null) {
            return pageA.name.localeCompare(pageB.name);
        }
        else if (pageA.prefix == null) {
            return 1;
        }
        else if (pageB.prefix == null) {
            return -1;
        }
        else {
            const prefixComparison = pageA.prefix - pageB.prefix;
            if (prefixComparison == 0) {
                return pageA.name.localeCompare(pageB.name);
            }
            else {
                return prefixComparison;
            }
        }
    }
    /**
     * Adds any user provided images that can be referenced directly in other pages
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addImages(igPath) {
        // If the user provided additional image files, include them
        const inputImagesPath = path_1.default.join(this.igDataPath, 'input', 'images');
        if (fs_extra_1.default.existsSync(inputImagesPath)) {
            fs_extra_1.default.copySync(inputImagesPath, path_1.default.join(igPath, 'input', 'images'));
        }
    }
    /**
     * Adds any user provided includes files
     * A user provided menu.xml will be in this folder. If one is not provided, the static one SUSHI provides will be used.
     *
     * @param {string} igPath - the path where the IG is exported to
     */
    addIncludeContents(igPath) {
        const includesPath = path_1.default.join(this.igDataPath, 'input', 'includes');
        if (fs_extra_1.default.existsSync(includesPath)) {
            fs_extra_1.default.copySync(includesPath, path_1.default.join(igPath, 'input', 'includes'));
        }
    }
    /**
     * Adds user provided ignoreWarnings.txt file if it exists; otherwise the static one SUSHI provides will be used.
     *
     * @param {string} igPath - the path where the IG is exported to
     */
    addIgnoreWarningsFile(igPath) {
        const ignorePath = path_1.default.join(this.igDataPath, 'input', 'ignoreWarnings.txt');
        if (fs_extra_1.default.existsSync(ignorePath)) {
            fs_extra_1.default.copyFileSync(ignorePath, path_1.default.join(igPath, 'input', 'ignoreWarnings.txt'));
        }
    }
    /**
     * Add each of the resources from the package to the ImplementationGuide JSON file.
     */
    addResources() {
        const resources = [
            ...sortBy_1.default(this.pkg.profiles, sd => sd.name),
            ...sortBy_1.default(this.pkg.extensions, sd => sd.name),
            ...sortBy_1.default(this.pkg.valueSets, valueSet => valueSet.name),
            ...sortBy_1.default(this.pkg.codeSystems, codeSystem => codeSystem.name)
        ];
        resources.forEach(r => {
            var _a, _b;
            this.ig.definition.resource.push({
                reference: { reference: `${r.resourceType}/${r.id}` },
                name: (_b = (_a = r.title, (_a !== null && _a !== void 0 ? _a : r.name)), (_b !== null && _b !== void 0 ? _b : r.id)),
                description: r.description,
                exampleBoolean: false
            });
        });
        const instances = sortBy_1.default(this.pkg.instances, instance => { var _a; return _a = instance.id, (_a !== null && _a !== void 0 ? _a : instance._instanceMeta.name); });
        instances.forEach(instance => {
            var _a, _b, _c, _d;
            const resource = {
                reference: {
                    reference: `${instance.resourceType}/${_a = instance.id, (_a !== null && _a !== void 0 ? _a : instance._instanceMeta.name)}`
                },
                name: (_b = instance._instanceMeta.title, (_b !== null && _b !== void 0 ? _b : instance._instanceMeta.name)),
                description: instance._instanceMeta.description
            };
            if (instance._instanceMeta.usage === 'Example') {
                const exampleUrl = (_d = (_c = instance.meta) === null || _c === void 0 ? void 0 : _c.profile) === null || _d === void 0 ? void 0 : _d.find(url => this.pkg.fish(url, utils_1.Type.Profile));
                if (exampleUrl) {
                    resource.exampleCanonical = exampleUrl;
                }
                else {
                    resource.exampleBoolean = true;
                }
            }
            else {
                resource.exampleBoolean = false;
            }
            this.ig.definition.resource.push(resource);
        });
    }
    /**
     * Adds any user provided resource files
     * This includes definitions in:
     * capabilities, extensions, models, operations, profiles, resources, vocabulary, examples
     * Based on: https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input
     *
     * @param {string} igPath - the path where the IG is exported to
     */
    addPredefinedResources(igPath) {
        var _a, _b;
        // Similar code for loading custom resources exists in load.ts loadCustomResources()
        const pathEnds = [
            'capabilities',
            'extensions',
            'models',
            'operations',
            'profiles',
            'resources',
            'vocabulary',
            'examples'
        ];
        for (const pathEnd of pathEnds) {
            const dirPath = path_1.default.join(this.igDataPath, 'input', pathEnd);
            if (fs_extra_1.default.existsSync(dirPath)) {
                const files = fs_extra_1.default.readdirSync(dirPath);
                for (const file of files) {
                    let resourceJSON;
                    if (file.endsWith('.json')) {
                        resourceJSON = fs_extra_1.default.readJSONSync(path_1.default.join(dirPath, file));
                        if (resourceJSON.resourceType == null || resourceJSON.id == null) {
                            utils_1.logger.error(`Resource at ${path_1.default.join(dirPath, file)} must define resourceType and id.`);
                            continue;
                        }
                        const resource = {
                            reference: {
                                reference: `${resourceJSON.resourceType}/${resourceJSON.id}`
                            },
                            name: resourceJSON.id,
                            description: resourceJSON.description
                        };
                        if (pathEnd === 'examples') {
                            const exampleUrl = (_b = (_a = resourceJSON.meta) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.find(url => { var _a; return _a = this.pkg.fish(url, utils_1.Type.Profile), (_a !== null && _a !== void 0 ? _a : this.fhirDefs.fishForFHIR(url, utils_1.Type.Profile)); });
                            if (exampleUrl) {
                                resource.exampleCanonical = exampleUrl;
                            }
                            else {
                                resource.exampleBoolean = true;
                            }
                        }
                        else {
                            resource.exampleBoolean = false;
                            // On some resources (Patient for example) these fields can be objects, avoid using them when this is true
                            const title = typeof resourceJSON.title === 'string' ? resourceJSON.title : null;
                            const name = typeof resourceJSON.name === 'string' ? resourceJSON.name : null;
                            if (title || name) {
                                resource.name = (title !== null && title !== void 0 ? title : name);
                            }
                        }
                        const existingIndex = this.ig.definition.resource.findIndex(r => r.reference.reference === resource.reference.reference);
                        if (existingIndex >= 0) {
                            if (this.ig.definition.resource[existingIndex].exampleBoolean ||
                                this.ig.definition.resource[existingIndex].exampleCanonical) {
                                // If it is replacing an existing example, preserve description and name from SUSHI
                                // Allows user method for setting description/name on external example
                                const oldDescription = this.ig.definition.resource[existingIndex].description;
                                const oldName = this.ig.definition.resource[existingIndex].name;
                                if (oldDescription)
                                    resource.description = oldDescription;
                                if (oldName)
                                    resource.name = this.ig.definition.resource[existingIndex].name;
                            }
                            this.ig.definition.resource[existingIndex] = resource;
                        }
                        else {
                            this.ig.definition.resource.push(resource);
                        }
                        fs_extra_1.default.copySync(path_1.default.join(dirPath, file), path_1.default.join(igPath, 'input', pathEnd, `${resourceJSON.resourceType}-${resourceJSON.id}.json`));
                    }
                }
            }
        }
    }
    /**
     * Writes the in-memory ImplementationGuide JSON to the IG output folder.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addImplementationGuide(igPath) {
        const igJsonPath = path_1.default.join(igPath, 'input', `ImplementationGuide-${this.ig.id}.json`);
        fs_extra_2.outputJSONSync(igJsonPath, this.ig, { spaces: 2 });
        utils_1.logger.info(`Generated ImplementationGuide-${this.ig.id}.json`);
    }
    /**
     * Creates an ig.ini file based on the package.json and exports it to the IG folder.
     * If the user specified an igi.ini file in the ig-data folder, then use its values
     * as long as they don't conflict with values already in package.json.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addIgIni(igPath) {
        var _a;
        // First generate the ig.ini from the package.json
        const iniObj = {};
        iniObj.ig = `input/ImplementationGuide-${this.pkg.config.name}.json`;
        iniObj.template = 'fhir.base.template';
        iniObj['usage-stats-opt-out'] = 'false';
        iniObj.copyrightyear = `${new Date().getFullYear()}+`;
        iniObj.license = (_a = this.pkg.config.license, (_a !== null && _a !== void 0 ? _a : 'CC0-1.0'));
        iniObj.version = this.pkg.config.version;
        iniObj.ballotstatus = 'CI Build';
        iniObj.fhirspec = 'http://build.fhir.org/';
        // Then add properties from the user-provided ig.ini (if applicable)
        const inputIniPath = path_1.default.join(this.igDataPath, 'ig.ini');
        let merged = false;
        if (fs_extra_1.default.existsSync(inputIniPath)) {
            merged = true;
            let inputIniContents = fs_extra_1.default.readFileSync(inputIniPath, 'utf8');
            // FHIR allows templates to have versions identified using #.  E.g.,
            //   template = hl7.fhir.template#0.1.0
            // The ini library, however, treats # as a comment unless it is escaped.  So if it exists, we need to escape it.
            inputIniContents = inputIniContents.replace(/^\s*template\s*=\s*[^#]*(#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, `\\${$1}`) : $0);
            const inputIni = ini_1.default.parse(inputIniContents);
            if (Object.keys(inputIni).length > 1 || inputIni.IG == null) {
                utils_1.logger.error('igi.ini file must contain an [IG] section with no other sections', {
                    file: inputIniPath
                });
            }
            else {
                Object.keys(inputIni.IG).forEach(key => {
                    if (key === 'ig' && inputIni.IG.ig !== iniObj.ig) {
                        utils_1.logger.error('igi.ini: sushi does not currently support overriding ig value.', {
                            file: inputIniPath
                        });
                    }
                    else if (key === 'license' && inputIni.IG.license !== iniObj.license) {
                        utils_1.logger.error(`igi.ini: license value (${inputIni.IG.license}) does not match license declared in package.json (${iniObj.license}).  Keeping ${iniObj.license}.`, { file: inputIniPath });
                    }
                    else if (key === 'version' && inputIni.IG.version !== iniObj.version) {
                        utils_1.logger.error(`igi.ini: version value (${inputIni.IG.version}) does not match version declared in package.json (${iniObj.version}).  Keeping ${iniObj.version}.`, { file: inputIniPath });
                    }
                    else {
                        iniObj[key] = inputIni.IG[key];
                    }
                });
            }
        }
        // Update the corresponding parameters in the ImplementationGuide JSON
        const copyrightParam = this.ig.definition.parameter.find(p => p.code === 'copyrightyear');
        copyrightParam.value = iniObj.copyrightyear;
        const releaseParam = this.ig.definition.parameter.find(p => p.code === 'releaselabel');
        releaseParam.value = iniObj.ballotstatus;
        // Now we need to do the reverse of what we did before.  If `#` is escaped, then unescape it.
        let outputIniContents = ini_1.default.encode(iniObj, { section: 'IG', whitespace: true });
        outputIniContents = outputIniContents.replace(/^template\s*=\s*.*?(\\#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, $1.slice(1)) : $0);
        // Finally, write it to disk
        fs_extra_2.outputFileSync(path_1.default.join(igPath, 'ig.ini'), outputIniContents);
        if (merged) {
            utils_1.logger.info('Merged ig-data/ig.ini w/ generated ig.ini');
        }
        else {
            utils_1.logger.info('Generated default ig.ini.');
        }
    }
    /**
     * Adds the package-list.json file to the IG.  If one already exists, it will be used, otherwise
     * it will be generated based on the package.json.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addPackageList(igPath) {
        var _a, _b, _c;
        // If the user provided an index.md file, use that
        const inputPackageListPath = path_1.default.join(this.igDataPath, 'package-list.json');
        if (fs_extra_1.default.existsSync(inputPackageListPath)) {
            let mismatch = false;
            const inputPackageList = fs_extra_1.default.readJSONSync(inputPackageListPath);
            if (inputPackageList['package-id'] !== this.pkg.config.name) {
                utils_1.logger.error(`package-list.json: package-id value (${inputPackageList['package-id']}) does not match name declared in package.json (${this.pkg.config.name}).  Ignoring custom package-list.json.`, { file: inputPackageListPath });
                mismatch = true;
            }
            if (inputPackageList.canonical !== this.pkg.config.canonical) {
                utils_1.logger.error(`package-list.json: canonical value (${inputPackageList.canonical}) does not match canonical declared in package.json (${this.pkg.config.canonical}).  Ignoring custom package-list.json.`, { file: inputPackageListPath });
                mismatch = true;
            }
            if (!mismatch) {
                fs_extra_1.default.copySync(inputPackageListPath, path_1.default.join(igPath, 'package-list.json'));
                utils_1.logger.info('Copied ig-data/package-list.json.');
                return;
            }
        }
        fs_extra_2.outputJSONSync(path_1.default.join(igPath, 'package-list.json'), {
            'package-id': this.pkg.config.name,
            title: (_a = this.pkg.config.title, (_a !== null && _a !== void 0 ? _a : this.pkg.config.name)),
            canonical: this.pkg.config.canonical,
            introduction: (_c = (_b = this.pkg.config.description, (_b !== null && _b !== void 0 ? _b : this.pkg.config.title)), (_c !== null && _c !== void 0 ? _c : this.pkg.config.name)),
            list: [
                {
                    version: 'current',
                    desc: 'Continuous Integration Build (latest in version control)',
                    path: this.pkg.config.url,
                    status: 'ci-build',
                    current: true
                },
                {
                    version: this.pkg.config.version,
                    fhirversion: '4.0.1',
                    date: '2099-01-01',
                    desc: 'Initial STU ballot (Mmm yyyy Ballot)',
                    path: this.pkg.config.url,
                    status: 'ballot',
                    sequence: 'STU 1'
                }
            ]
        }, { spaces: 2 });
        utils_1.logger.info('Generated default package-list.json');
    }
}
exports.IGExporter = IGExporter;
//# sourceMappingURL=IGExporter.js.map