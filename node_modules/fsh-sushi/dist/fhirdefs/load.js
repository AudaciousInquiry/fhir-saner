"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const tar_1 = __importDefault(require("tar"));
const request_promise_native_1 = __importDefault(require("request-promise-native"));
const temp_1 = __importDefault(require("temp"));
const utils_1 = require("../utils");
/**
 * Loads a dependency from user FHIR cache or from online
 * @param {string} packageName - The name of the package to load
 * @param {string} version - The version of the package to load
 * @param {FHIRDefinitions} FHIRDefs - The FHIRDefinitions to load the dependencies into
 * @param {string} cachePath - The path to load the package into
 * @returns {Promise<FHIRDefinitions>} the loaded FHIRDefs
 * @throws {PackageLoadError} when the desired package can't be loaded
 */
function loadDependency(packageName, version, FHIRDefs, cachePath = path_1.default.join(os_1.default.homedir(), '.fhir', 'packages')) {
    return __awaiter(this, void 0, void 0, function* () {
        const fullPackageName = `${packageName}#${version}`;
        const loadPath = path_1.default.join(cachePath, fullPackageName, 'package');
        let loadedPackage;
        if (version != 'current') {
            utils_1.logger.info(`Checking local cache for ${fullPackageName}...`);
            loadedPackage = loadFromPath(loadPath, fullPackageName, FHIRDefs);
            if (loadedPackage) {
                utils_1.logger.info(`Found ${fullPackageName} in local cache.`);
            }
            else {
                utils_1.logger.info(`Did not find ${fullPackageName} in local cache.`);
            }
        }
        if (!loadedPackage) {
            let packageUrl;
            if (version === 'dev') {
                // Dev packages must be present in local FHIR cache
                throw new errors_1.DevPackageLoadError(fullPackageName);
            }
            else if (version === 'current') {
                // Current packages need to be loaded using build.fhir.org
                const baseUrl = 'http://build.fhir.org/ig';
                const res = yield request_promise_native_1.default.get({
                    uri: `${baseUrl}/qas.json`,
                    json: true
                });
                // Find matching packages and sort by date to get the most recent
                let newestPackage;
                if (res && res.length > 0) {
                    const matchingPackages = res.filter(p => p['package-id'] === packageName);
                    newestPackage = matchingPackages.sort((p1, p2) => {
                        return Date.parse(p2['date']) - Date.parse(p1['date']);
                    })[0];
                }
                if (newestPackage && newestPackage.repo) {
                    // Find the package based on the first two parts of the package's 'repo' property.  E.g.,
                    //   "repo": "HL7/US-Core-R4/branches/test-branch-tweak/qa.json"
                    // means to find the package at:
                    //    http://build.fhir.org/ig/HL7/US-Core-R4/package.tgz
                    // See: https://chat.fhir.org/#narrow/stream/179165-committers/topic/Build.20Problem/near/187610137
                    const [org, repo] = newestPackage.repo.split('/');
                    packageUrl = `${baseUrl}/${org}/${repo}/package.tgz`;
                }
                else {
                    throw new errors_1.CurrentPackageLoadError(fullPackageName);
                }
            }
            else {
                // All non-current packages are stored at packages.fhir.org
                packageUrl = `http://packages.fhir.org/${packageName}/${version}`;
            }
            // Create a temporary file and write the package to there
            temp_1.default.track();
            const tempFile = temp_1.default.openSync();
            const targetDirectory = path_1.default.join(cachePath, fullPackageName);
            let res;
            try {
                utils_1.logger.info(`Downloading ${fullPackageName}...`);
                res = yield request_promise_native_1.default.get({
                    uri: packageUrl,
                    encoding: null,
                    transform: (body, response) => {
                        if (response.statusCode < 200 || response.statusCode > 299) {
                            return body.toString();
                        }
                        return body;
                    }
                });
                utils_1.logger.info(`Downloaded ${fullPackageName}`);
            }
            catch (e) {
                e.message = `${e.statusCode} - ${e.response}`;
                throw e;
            }
            fs_extra_1.default.ensureDirSync(targetDirectory);
            fs_extra_1.default.writeFileSync(tempFile.path, res);
            // Extract the package from that temporary file location
            tar_1.default.x({
                cwd: targetDirectory,
                file: tempFile.path,
                sync: true,
                strict: true
            });
            // Now try to load again from the path
            loadedPackage = loadFromPath(loadPath, fullPackageName, FHIRDefs);
            if (!loadedPackage) {
                // If we fail again, then we couldn't get the package locally or from online
                throw new errors_1.PackageLoadError(fullPackageName);
            }
        }
        return FHIRDefs;
    });
}
exports.loadDependency = loadDependency;
/**
 * Loads custom resources defined in ig-data into FHIRDefs
 * @param {string} input - The input path to the cli
 * @param {FHIRDefinitions} defs - The FHIRDefinitions object to load definitions into
 */
function loadCustomResources(input, defs) {
    // Similar code for loading custom resources exists in IGExporter.ts addPredefinedResources()
    const pathEnds = [
        'capabilities',
        'extensions',
        'models',
        'operations',
        'profiles',
        'resources',
        'vocabulary',
        'examples'
    ];
    for (const pathEnd of pathEnds) {
        let xmlFile = false;
        let invalidFile = false;
        const dirPath = path_1.default.join(input, 'ig-data', 'input', pathEnd);
        if (fs_extra_1.default.existsSync(dirPath)) {
            const files = fs_extra_1.default.readdirSync(dirPath);
            for (const file of files) {
                let resourceJSON;
                if (file.endsWith('.json')) {
                    resourceJSON = fs_extra_1.default.readJSONSync(path_1.default.join(dirPath, file));
                }
                else {
                    xmlFile = xmlFile || file.endsWith('.xml');
                    invalidFile = true;
                    continue;
                }
                if (pathEnd !== 'examples') {
                    // add() will only add resources of resourceType:
                    // StructureDefinition, ValueSet, CodeSystem, or ImplementationGuide
                    defs.add(resourceJSON);
                }
            }
        }
        if (invalidFile) {
            let message = `Invalid file detected in directory ${dirPath}. Input FHIR definitions must be JSON.`;
            if (xmlFile) {
                message += ' XML format not supported.';
            }
            utils_1.logger.error(message);
        }
    }
}
exports.loadCustomResources = loadCustomResources;
/**
 * Loads a set of JSON files at targetPath into FHIRDefs
 * @param {string} targetPath - The path to the directory containing the JSON definitions
 * @param {string} targetPackage - The name of the package we are trying to load
 * @param {FHIRDefinitions} FHIRDefs - The FHIRDefinitions object to load defs into
 * @returns {string} the name of the loaded package if successful
 */
function loadFromPath(targetPath, targetPackage, FHIRDefs) {
    if (FHIRDefs.packages.indexOf(targetPackage) < 0) {
        const originalSize = FHIRDefs.size();
        if (fs_extra_1.default.existsSync(targetPath)) {
            const files = fs_extra_1.default.readdirSync(targetPath);
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const def = JSON.parse(fs_extra_1.default.readFileSync(path_1.default.join(targetPath, file), 'utf-8').trim());
                    FHIRDefs.add(def);
                }
            }
        }
        // If we did successfully load definitions, mark this package as loaded
        if (FHIRDefs.size() > originalSize) {
            FHIRDefs.packages.push(targetPackage);
            return targetPackage;
        }
    }
    else {
        // If the package has already been loaded, just return the targetPackage string
        return targetPackage;
    }
}
exports.loadFromPath = loadFromPath;
//# sourceMappingURL=load.js.map